---
title: "Ordered Network Analysis (ONA) Demo"
author: "Yuanru Tan"
date: "Last updated: November 2022"
output:
  html_notebook:
    toc: yes
  html_document:
    toc: yes
    df_print: paged
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

## 1. Install packages

Note: when installing ona or tma package, if you are a Mac user and you run into "package has non-zero exit status" after replying "Yes" to the question "do you want to attempt to install these from sources? (Yes/no/cancel)", please follow this link to install the gfortran that matches the version of your MacOS: https://github.com/fxcoudert/gfortran-for-macOS/releases. After you finish the gfortran process, restart your R studio before you install the packages again. 

```{r message = FALSE}
install.packages("ona", repos = c("https://epistemic-analytics.gitlab.io/qe-packages/ona/cran/", "https://cran.rstudio.org"))
```

install the other two packages that are needed for ona 
```{r message = FALSE}
 install.packages("tma", repos = c("https://epistemic-analytics.gitlab.io/qe-packages/tma/cran/", "https://cran.rstudio.org"))
# install.packages("magrittr")
```


```{r message = FALSE}
library(ona)
library(tma)
library(magrittr)
```


## 2. Identify Columns To Accumulate

In this example, we use a data set called *test_rs_data*, which includes a subset of group discussion chat data contributed by a group of college students. These students played the role of an intern at a fictional engineering design firm. 
```{r}
my_data <- data.table::as.data.table(tma::test_rsdata)
```

Before using the connection accumulation function, we need to first identify which columns of the data to use for our *units*, *conversation*, and *codes*. The accumulation process requires individual data frames for each of the respective parameters, so we will subset the `test_rsdata` using the identified columns.

```{r}
my_units <- c("UserName","Condition","GroupName") 

my_hoo_rules <- conversation_rules(
  (Condition %in% UNIT$Condition & GroupName %in% UNIT$GroupName)
)

my_codes = c('Data',
          'Technical.Constraints',
          'Performance.Parameters',
          'Client.and.Consultant.Requests',
          'Design.Reasoning',
          'Collaboration')
```


## 3. Run the Accumulation

To run the accumulation, we pass along our subset dataframes and indicate the size of our stanza.window.
```{r}
accum <-
  contexts(my_data, units_by = my_units, hoo_rules = my_hoo_rules) %>%
  accumulate_contexts(codes = my_codes, 
                      decay.function = decay(simple_window, window_size = 7),
                      return.ena.set = FALSE, norm.by = NULL)
```


## 4. Generate the ONA Set

An ONA set can be generated by passing along the result of accumulation to `model` which performs a dimensional reduction on the connection counts and runs an optimization to routine to decide the positions of the network nodes in the reduced space.

### 4.1 Singular Value Decomposition (SVD)

The most basic ONA space is the one generated via SVD on the normalized and centered connection counts. Typically, units are plotted on the first two dimensions because these account for the most variance among the units. However, any SVD dimension can be chosen.

```{r}
set <-
  model(accum)
```

### 4.2 Means Rotation (MR)

MR is a dimensional reduction that can be applied when the units are divided into two discrete groups. The resulting space highlights the differences between groups (if any) by constructing a dimensional reduction that places the means of the groups as close as possible to the x-axis of the space. Creating a means rotated set is fairly similar to a standard set, however we will define the rotation function along with the groups of rotated points that will be rotated along their means. Besides SVD, the `model` function in **ONA** package comes with a parameter for means rotation, which is set as the `rotate.using ="mean"`. Along with the function, `rotation.params` is set as the parameters we want to pass along to the rotation function. The means rotation function expects `rotation.params` to be a `list` with two named elements, each containing a logical vector representing the rows of units to be included in particular group.

In this example, we will compare the two specific groups, defined in `test_rsdata` by the `Condition` column: "FirstGame" or relative novices and "SecondGame" or relative experts


```{r }
my_rotation.params = 
  list(FirstGame=accum$meta.data$Condition=="FirstGame",
       SecondGame=accum$meta.data$Condition=="SecondGame")

set <-
  model(accum,                                 # The previously run accumulation above
        rotate.using ="mean",                  # Function provided by ONA
        rotation.params = my_rotation.params   # The defined paremeters for rotation
        )
```


# 5. Plotting 

I usually like to set these visual parameters before plotting, so that we can make sure we are using the same value globally, so that we can compare all plots visually in a consistent manner. Feel free to ask me what each parameter means if its name is not self explanatory enough. 

```{r}
node_size_multiplier = 0.3
node_position_multiplier = 1
edge_arrow_saturation_multiplier = 1.5
edge_size_multiplier = 1
```


Plot the individual network for FirstGame and SecondGame, and their subtracted network
```{r}
# FirstGame individual plot
plot(set, title = "FirstGame (red)") %>%
  units(
    points=set$points$Condition$FirstGame, 
    points_color = "red",
    show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
  edges(
    weights =set$line.weights$Condition$FirstGame,
    edge_size_multiplier = edge_size_multiplier,
    edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
    node_position_multiplier = node_position_multiplier,
    edge_color = c("red")) %>%
  nodes(
    node_size_multiplier = node_size_multiplier,
    node_position_multiplier = node_position_multiplier,
    self_connection_color = c("red"))

# SecondGame individual plot
plot(set, title = "SecondGame (blue)") %>%
  units(
    points=set$points$Condition$SecondGame, 
    points_color = "blue", 
    show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
  edges(
    weights = set$line.weights$Condition$SecondGame,
    edge_size_multiplier = edge_size_multiplier,
    edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
    node_position_multiplier = node_position_multiplier,
    edge_color = c("blue")) %>%
  nodes(
    node_size_multiplier = node_size_multiplier,
    node_position_multiplier = node_position_multiplier,
    self_connection_color = c("blue"))

# FirstGame and SecondGame subtracted plot
plot(set, title = "Difference: FirstGame (red) vs SecondGame (blue)") %>%
  units(
    points = set$points$Condition$FirstGame, 
    points_color = "red",
    show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
  units(
    points = set$points$Condition$SecondGame, 
    points_color = "blue",
    show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
  edges(
    weights = (colMeans(set$line.weights$Condition$FirstGame) - colMeans(set$line.weights$Condition$SecondGame)),
    edge_size_multiplier = edge_size_multiplier,
    edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
    node_position_multiplier = node_position_multiplier,
    edge_color = c("red","blue")) %>%
  nodes(
    node_size_multiplier = node_size_multiplier,
    node_position_multiplier = node_position_multiplier,
    self_connection_color = c("red","blue"))
```


```{r compare two individual units}
# first game
plot(set, title = "steven z.FirstGame.Electric") %>%
  units(
    points=set$points$ENA_UNIT$`steven z.FirstGame.Electric`, 
    points_color = "red", 
    show_mean = FALSE, show_points = TRUE, with_ci = FALSE) %>%
  edges(
    weights = set$line.weights$ENA_UNIT$`steven z.FirstGame.Electric`,
    edge_size_multiplier = edge_size_multiplier,
    edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
    node_position_multiplier = node_position_multiplier,
    edge_color = c("red")) %>%
  nodes(
    node_size_multiplier = node_size_multiplier,
    node_position_multiplier = node_position_multiplier,
    self_connection_color = c("red"))

# second game
plot(set, title = "samuel o.SecondGame.2") %>%
  units(
    points=set$points$ENA_UNIT$`samuel o.SecondGame.2`, 
    points_color = "blue", 
    show_mean = FALSE, show_points = TRUE, with_ci = FALSE) %>%
  edges(
    weights = set$line.weights$ENA_UNIT$`samuel o.SecondGame.2`,
    edge_size_multiplier = edge_size_multiplier,
    edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
    node_position_multiplier = node_position_multiplier,
    edge_color = c("blue")) %>%
  nodes(
    node_size_multiplier = node_size_multiplier,
    node_position_multiplier = node_position_multiplier,
    self_connection_color = c("blue"))

# units difference
mean1 = as.vector(as.matrix(set$line.weights$ENA_UNIT$`steven z.FirstGame.Electric`[2,]))
mean2 = as.vector(as.matrix(set$line.weights$ENA_UNIT$`samuel o.SecondGame.2`[2,]))

subtracted.mean = mean1 - mean2

plot(set, title = "subtracted network of steven z.FirstGame.Electric and SecondGame.luke u") %>% 
  units(
    points = set$points$ENA_UNIT$`steven z.FirstGame.Electric`, points_color = "red",
    point_position_multiplier = 1.5,
    show_mean = FALSE, show_points = TRUE, with_ci = FALSE) %>%
  units(
    points = set$points$ENA_UNIT$`samuel o.SecondGame.2`, points_color = "blue",
    point_position_multiplier = 1.5,
    show_mean = FALSE, show_points = TRUE, with_ci = FALSE) %>%
  edges(
    weights = subtracted.mean,
    edge_size_multiplier = edge_size_multiplier,
    edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
    node_position_multiplier = node_position_multiplier,
    edge_color = c("red", "blue")) %>%
  nodes(
    node_size_multiplier = node_size_multiplier,
    node_position_multiplier = node_position_multiplier,
    self_connection_color = c("red", "blue")) 
```

## 6. Statistically compare two groups

It is often useful to use the outputs of ONA models in subsequent analyses. The most commonly used outputs are the ONA scores/plotted points. For example, we can test for statistical differences between groups in our data in terms of their ONA scores. Here we ask: are the connections that one group makes statistically different from those made by another group. In the example below, I use a students t-Test to test for differences between the first and second game groups.

```{r}
# subset points from all dimensions for each group
first = set$points$Condition$FirstGame
first_points <- first[seq_len(nrow(first)) %% 2 == 0, ]

second = set$points$Condition$SecondGame
second_points <- second[seq_len(nrow(second)) %% 2 == 0, ]

# subset points from the first dimension and second dimension for test for differences between the points of two groups
first_points_d1 = as.matrix(first_points)[,1]
second_points_d1 = as.matrix(second_points)[,1]

first_points_d2 = as.matrix(first_points)[,2]
second_points_d2 = as.matrix(second_points)[,2]

# run t-Tests 
t_test_d1 = t.test(first_points_d1, second_points_d1)
t_test_d2 = t.test(first_points_d2, second_points_d2)

t_test_d1
t_test_d2

#non parametric tests

w_test_d1 = wilcox.test(first_points_d1, second_points_d1)
w_test_d2 = wilcox.test(first_points_d2, second_points_d2)

w_test_d1
w_test_d2

```

# 7. Model goodness of fit
```{r}
ona::correlations(set)
```

# more
```{r}
# try the same data using ENA
library(rENA)
ena_set = 
ena(
  data = RS.data,
  units = c("UserName","Condition", "GroupName"),
  conversation = c("Condition","GroupName"),
  codes = c('Data',
            'Technical.Constraints',
            'Performance.Parameters',
            'Client.and.Consultant.Requests',
            'Design.Reasoning',
            'Collaboration'),
  window.size.back = 7
)

plot = ena.plotter(ena_set ,
                      points = T,
                      mean = T, 
                      network = T,
                      print.plots = T,
                      groupVar = "Condition",
                      groups = c("SecondGame", "FirstGame"),
                      subtractionMultiplier = 4)

plot$plots$`FirstGame-SecondGame`
```